[{"C:\\Users\\Max\\Desktop\\BA GitLab\\bachelorarbeit-max-moebius\\matching-ui\\src\\index.js":"1","C:\\Users\\Max\\Desktop\\BA GitLab\\bachelorarbeit-max-moebius\\matching-ui\\src\\App.js":"2","C:\\Users\\Max\\Desktop\\BA GitLab\\bachelorarbeit-max-moebius\\matching-ui\\src\\reportWebVitals.js":"3","C:\\Users\\Max\\Desktop\\BA GitLab\\bachelorarbeit-max-moebius\\matching-ui\\src\\StartView.js":"4","C:\\Users\\Max\\Desktop\\BA GitLab\\bachelorarbeit-max-moebius\\matching-ui\\src\\ObjectChoice\\ObjectChoiceView.js":"5","C:\\Users\\Max\\Desktop\\BA GitLab\\bachelorarbeit-max-moebius\\matching-ui\\src\\Matching\\MatchingView.js":"6","C:\\Users\\Max\\Desktop\\BA GitLab\\bachelorarbeit-max-moebius\\matching-ui\\src\\ObjectChoice\\LeftTreeView.js":"7","C:\\Users\\Max\\Desktop\\BA GitLab\\bachelorarbeit-max-moebius\\matching-ui\\src\\ObjectChoice\\RightTreeView.js":"8","C:\\Users\\Max\\Desktop\\BA GitLab\\bachelorarbeit-max-moebius\\matching-ui\\src\\ObjectChoice\\FilterComponent.js":"9","C:\\Users\\Max\\Desktop\\BA GitLab\\bachelorarbeit-max-moebius\\matching-ui\\src\\Matching\\PopUp.js":"10","C:\\Users\\Max\\Desktop\\BA GitLab\\bachelorarbeit-max-moebius\\matching-ui\\src\\Matching\\AssignmentTables.js":"11","C:\\Users\\Max\\Desktop\\BA GitLab\\bachelorarbeit-max-moebius\\matching-ui\\src\\Matching\\SaveMatchingButton.js":"12"},{"size":1477,"mtime":1617173452498,"results":"13","hashOfConfig":"14"},{"size":528,"mtime":499162500000,"results":"15","hashOfConfig":"16"},{"size":362,"mtime":499162500000,"results":"17","hashOfConfig":"14"},{"size":1021,"mtime":1617221889959,"results":"18","hashOfConfig":"14"},{"size":5821,"mtime":1617223612555,"results":"19","hashOfConfig":"14"},{"size":8693,"mtime":1617223612576,"results":"20","hashOfConfig":"14"},{"size":3074,"mtime":1617211783771,"results":"21","hashOfConfig":"14"},{"size":7212,"mtime":1617217009577,"results":"22","hashOfConfig":"14"},{"size":12620,"mtime":1617208576616,"results":"23","hashOfConfig":"14"},{"size":16060,"mtime":1617203985313,"results":"24","hashOfConfig":"14"},{"size":28739,"mtime":1617217291746,"results":"25","hashOfConfig":"14"},{"size":9909,"mtime":1617193990704,"results":"26","hashOfConfig":"14"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"29"},"1wvv28i",{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},"1f2xf1e",{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"29"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"37","messages":"38","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"29"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"29"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47","usedDeprecatedRules":"29"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"50","usedDeprecatedRules":"29"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"53","usedDeprecatedRules":"29"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"56","usedDeprecatedRules":"29"},"C:\\Users\\Max\\Desktop\\BA GitLab\\bachelorarbeit-max-moebius\\matching-ui\\src\\index.js",[],["57","58"],"C:\\Users\\Max\\Desktop\\BA GitLab\\bachelorarbeit-max-moebius\\matching-ui\\src\\App.js",[],["59","60"],"C:\\Users\\Max\\Desktop\\BA GitLab\\bachelorarbeit-max-moebius\\matching-ui\\src\\reportWebVitals.js",[],"C:\\Users\\Max\\Desktop\\BA GitLab\\bachelorarbeit-max-moebius\\matching-ui\\src\\StartView.js",[],"C:\\Users\\Max\\Desktop\\BA GitLab\\bachelorarbeit-max-moebius\\matching-ui\\src\\ObjectChoice\\ObjectChoiceView.js",["61"],"C:\\Users\\Max\\Desktop\\BA GitLab\\bachelorarbeit-max-moebius\\matching-ui\\src\\Matching\\MatchingView.js",[],"C:\\Users\\Max\\Desktop\\BA GitLab\\bachelorarbeit-max-moebius\\matching-ui\\src\\ObjectChoice\\LeftTreeView.js",[],"C:\\Users\\Max\\Desktop\\BA GitLab\\bachelorarbeit-max-moebius\\matching-ui\\src\\ObjectChoice\\RightTreeView.js",[],"C:\\Users\\Max\\Desktop\\BA GitLab\\bachelorarbeit-max-moebius\\matching-ui\\src\\ObjectChoice\\FilterComponent.js",["62","63","64","65","66","67","68"],"import React from 'react';\r\nimport Grid from \"@material-ui/core/Grid\";\r\nimport {Select, Table} from \"antd\";\r\nimport {DeleteOutlined} from \"@ant-design/icons\";\r\nimport {AgGridColumn, AgGridReact} from \"ag-grid-react\";\r\n\r\n/**\r\n * Creates Filter component with (DropDown, Input, Button and Grid/Table).\r\n * Allows filtering of data from \"Part Database API\".\r\n */\r\nexport default class FilterComponent extends React.Component{\r\n    /**\r\n     * {Object[]} filterProperties contains all property names (for filtering) from \"Part Database\"\r\n     * {Object[]} filterList contains currently used filter\r\n     * {Integer} longestFilterNameLength the length of longest property name for width of DropDown component\r\n     * {String} filterPropertyIdentifier contains the name of the filter to be added\r\n     * {String} filterPropertyValue contains the value of the filter to be added\r\n     * {String} filterPropertyGroup contains the group of the filter to be added\r\n     * {boolean} dropDownPropertyChanged is true if in DropDown a new property is selected\r\n     */\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            filterProperties: [], filterList: [],\r\n            longestFilterNameLength: 0,\r\n            filterPropertyIdentifier: \"\", filterPropertyValue: \"\", filterPropertyGroup: \"\",\r\n            dropDownPropertyChanged: false,\r\n        };\r\n\r\n        this.handleFilter = this.handleFilter.bind(this);\r\n        this.handleDeletion = this.handleDeletion.bind(this);\r\n        this.handleInputFilter = this.handleInputFilter.bind(this);\r\n    }\r\n\r\n    /**\r\n     * Creates with properties and categories a list of filter.\r\n     * Goes through the category list and add the elements to filter property list.\r\n     * Goes through the property list and add the elements to filter property list.\r\n     * Also determine length of longest filter name.\r\n     *\r\n     * @param {Object[]} categoryList contains all object categories\r\n     * @param {Object[]} propertyList contains all properties from \"Part Database\"\r\n     * @param {Object[]} filterProperties contains all filter in right format for DropDown component\r\n     * @param {String} longestWordLength the length of longest filter name\r\n     */\r\n    calculateFilterList(categoryList, propertyList, filterProperties, longestWordLength) {\r\n        const CategoryId = \"Category\", PropertyId = \"Property\";\r\n\r\n        categoryList.map((item, index) => {\r\n            filterProperties[index] = {group: CategoryId, name: item.name, identifier: item.identifier};\r\n\r\n            if (longestWordLength < item.name.length) {\r\n                longestWordLength = item.name.length;\r\n            }\r\n        })\r\n\r\n        let categoryIndex = categoryList.length;\r\n\r\n        propertyList.map((item, index) => {\r\n            filterProperties[index + categoryIndex] = {group: PropertyId, name: item.name, identifier: item.identifier};\r\n\r\n            if (longestWordLength < item.name.length) {\r\n                longestWordLength = item.name.length;\r\n            }\r\n        });\r\n\r\n        this.setState({filterProperties: filterProperties, longestFilterNameLength: longestWordLength});\r\n    }\r\n\r\n    /**\r\n     * Fetches all properties and categories from API.\r\n     * Calculate list of filter for DropDown.\r\n     */\r\n    async componentDidMount() {\r\n        let propertyList = [], categoryList = [], filterProperties = [];\r\n        let iterator = 0, longestWordLength = 0;\r\n        const allPartDatPropertiesURL = \"http://localhost:9000/api/properties/\";\r\n        const allPartDatCategoriesURL = \"http://localhost:9000/api/categories/\";\r\n        const childrenProperty = \"children\";\r\n\r\n        const responsePropertiesPartDat = await fetch(allPartDatPropertiesURL);\r\n        const propertyJson = await responsePropertiesPartDat.json();\r\n\r\n        propertyJson.map((item) =>{\r\n            if(!item.hasOwnProperty(childrenProperty)){\r\n                propertyList[iterator] = item;\r\n                ++iterator;\r\n            }\r\n        })\r\n\r\n        const responseCategoriesPartDat = await fetch(allPartDatCategoriesURL);\r\n        const categoryJson = await responseCategoriesPartDat.json();\r\n\r\n        categoryJson.map((item, index) =>{\r\n            categoryList[index] = item;\r\n        })\r\n\r\n        await this.calculateFilterList(categoryList, propertyList, filterProperties, longestWordLength);\r\n    }\r\n\r\n    /**\r\n     * If component {@link filterGrid} available, resizes its columns.\r\n     * {@link dropDownPropertyChanged} is true,borderColor of {@link filterInput} changes to black.\r\n     *\r\n     * @param prevProps\r\n     * @param prevState\r\n     * @param snapshot\r\n     */\r\n    componentDidUpdate(prevProps: Readonly<P>, prevState: Readonly<S>, snapshot: SS) {\r\n        const CategoryId = \"Category\", colorBlack = \"black\";\r\n\r\n        if(this.filterGrid){\r\n            this.filterGrid.columnApi.autoSizeAllColumns();\r\n        }\r\n\r\n        if(this.state.filterPropertyIdentifier !== prevProps.filterPropertyIdentifier\r\n            || this.state.filterPropertyValue !== prevProps.filterPropertyValue){\r\n            this.filterInput.style.borderColor = colorBlack;\r\n        }\r\n\r\n        if(this.state.dropDownPropertyChanged){\r\n            this.setState({filterPropertyValue: \"\", dropDownPropertyChanged: false});\r\n        }\r\n    }\r\n\r\n    /**\r\n     * New filter get added to list of filter.\r\n     * If filter already in use, only the value changes.\r\n     */\r\n    addFilter() {\r\n        let filterList = this.state.filterList;\r\n        let filterNameAlreadyInUse = false;\r\n\r\n        for (let i = 0; i < filterList.length; i++) {\r\n            if (filterList[i].name === this.state.filterPropertyIdentifier) {\r\n                filterList[i].value = this.state.filterPropertyValue;\r\n                filterNameAlreadyInUse = true;\r\n            }\r\n        }\r\n\r\n        if (!filterNameAlreadyInUse) {\r\n            filterList.push({key: this.state.filterPropertyIdentifier, name: this.state.filterPropertyIdentifier, value: this.state.filterPropertyValue});\r\n\r\n            this.setState({filterList: filterList});\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Event handler.\r\n     * RegEx only accept in string: first a number in any length, than the char \":\" and than a number of any length.\r\n     * If new filter property is a category or not matches the regEx, borderColor of {@link filterInput} gets red and function returns.\r\n     * If try to add a category filter property twice without change it, also returns (shows if new filter is a category and the identifier is also category).\r\n     * Calculate and add new filter with given name, value and group of the new filter.\r\n     * Callback to {@link ObjectChoiceView.handleFilterListChanged} with the {@link filterList}.\r\n     */\r\n    async handleFilter(){\r\n        const filterValueRegEx = new RegExp(\"^([-+]?[0-9]+):([-+]?[0-9]+)$\");\r\n        const matches = filterValueRegEx.exec(this.state.filterPropertyValue);\r\n        const CategoryGroupIdentifier = \"Category\", colorRed = \"red\", categoryId = \"category\";\r\n\r\n        if(this.state.filterPropertyGroup !== CategoryGroupIdentifier && (matches === null || parseInt(matches[1]) > parseInt(matches[2]))){\r\n            this.filterInput.style.borderColor = colorRed;\r\n            return;\r\n        }\r\n\r\n        if(this.state.filterPropertyGroup === CategoryGroupIdentifier){\r\n            if(this.state.filterPropertyIdentifier === categoryId){\r\n                return\r\n            }\r\n\r\n            let newValue = this.state.filterPropertyIdentifier;\r\n\r\n            await this.setState({filterPropertyValue: newValue, filterPropertyIdentifier: categoryId})\r\n        }\r\n\r\n        await this.addFilter();\r\n        this.filterGrid.api.refreshCells({force: true});\r\n\r\n        this.setState({filterPropertyValue: \"\"});\r\n\r\n        this.props.filterListChange(this.state.filterList);\r\n    }\r\n\r\n    /**\r\n     * Event handler.\r\n     * Deletes the active filter that's in same row as the pressed button.\r\n     * Callback to {@link ObjectChoiceView.handleFilterListChanged} with the {@link filterList}.\r\n     *\r\n     * @param {Object} args contains the active filter\r\n     */\r\n    async handleDeletion(args){\r\n        let filterList = this.state.filterList;\r\n\r\n        for (let i = 0; i < filterList.length; i++) {\r\n            if(args.data.name === filterList[i].name){\r\n                filterList.splice(i, 1);\r\n            }\r\n        }\r\n\r\n        this.props.filterListChange(filterList);\r\n\r\n        await this.setState({filterList: filterList});\r\n        this.filterGrid.api.refreshCells({force: true});\r\n    }\r\n\r\n    /**\r\n     * Event handler.\r\n     * Sets value for new filter.\r\n     *\r\n     * @param {Object} args the value of the Input component\r\n     */\r\n    handleInputFilter(args){\r\n        this.setState({filterPropertyValue: args.target.value});\r\n    }\r\n\r\n    /**\r\n     * Disables filter input if category is selected.\r\n     * Transforms {@link filterProperties} into right form, to show in DropDown component.\r\n     * Contains DropDown component to select a filter name for new filter.\r\n     * Contains Input component to enter value for new filter.\r\n     * Contains Button component to accept filter name and value as new filter.\r\n     * Contains GridComponent to show currently used filter (deletion of filter possible).\r\n     */\r\n    render(){\r\n        const screenWidth = window.innerWidth;\r\n        const screenHeight = window.innerHeight;\r\n        let filterInputDisable = true;\r\n        let filterProperties = this.state.filterProperties;\r\n        let categories = [], properties = [];\r\n        let groupedFilterProperties = [];\r\n\r\n        const {Option, OptGroup} = Select;\r\n\r\n        const dropDownStyle = {\r\n            width: this.state.longestFilterNameLength * 8,\r\n            minWidth: screenWidth * 0.1,\r\n            maxWidth: screenWidth * 0.25\r\n        }\r\n\r\n        const gridStyle = {\r\n            height: screenHeight*0.192,\r\n            width: screenWidth*0.325,\r\n        }\r\n\r\n        const buttonStyle = {\r\n            height: screenHeight*0.04,\r\n            display: \"flex\",\r\n            alignItems: \"center\",\r\n        }\r\n\r\n        if(this.state.filterPropertyGroup === \"Property\"){\r\n            filterInputDisable = false;\r\n        }\r\n\r\n        filterProperties.map((property) => {\r\n            if(property.group === \"Category\"){\r\n                categories.push(<Option key={property.identifier} group={property.group}>{property.name}</Option>);\r\n            }\r\n            else {\r\n                properties.push(<Option key={property.identifier} group={property.group}>{property.name}</Option>);\r\n            }\r\n        });\r\n\r\n        groupedFilterProperties.push(<OptGroup key={\"category\"} label={\"Category\"}>{categories}</OptGroup>);\r\n        groupedFilterProperties.push(<OptGroup key={\"property\"} label={\"Property\"}>{properties}</OptGroup>);\r\n\r\n        return(\r\n            <div>\r\n                <Grid container spacing={1} alignItems={\"center\"}>\r\n                    <Grid item>\r\n                        <Select style={dropDownStyle} placeholder=\"Select or search property\" showSearch={true}\r\n                        onSelect={(value, option) => this.setState({filterPropertyIdentifier: option.key, filterPropertyGroup: option.group, dropDownPropertyChanged: true})}>\r\n                            {groupedFilterProperties}\r\n                        </Select>\r\n                    </Grid>\r\n                    <Grid item>\r\n                        <input ref={ref => this.filterInput = ref} placeholder={\"e.g. 1:10\"} disabled={filterInputDisable} value={this.state.filterPropertyValue} onChange={this.handleInputFilter}/>\r\n                    </Grid>\r\n                    <Grid item xs={8}>\r\n                        <button onClick={this.handleFilter}>Save filter</button>\r\n                    </Grid>\r\n                </Grid>\r\n                <Grid container spacing={1} alignItems={\"center\"}>\r\n                    <Grid item style={gridStyle} className=\"ag-theme-alpine\">\r\n                        <AgGridReact id={\"filterGrid\"} ref={ref => this.filterGrid = ref} key={this.state.filterList}\r\n                                     rowData={this.state.filterList}>\r\n                            <AgGridColumn headerName={\"Filter name\"} field={\"name\"}/>\r\n                            <AgGridColumn headerName={\"Value\"} field={\"value\"}/>\r\n                            <AgGridColumn cellRendererFramework={(args) => (<button style={buttonStyle} onClick={ () => this.handleDeletion(args)}><DeleteOutlined/></button>)}/>\r\n                        </AgGridReact>\r\n                    </Grid>\r\n                </Grid>\r\n            </div>\r\n        );\r\n    }\r\n}","C:\\Users\\Max\\Desktop\\BA GitLab\\bachelorarbeit-max-moebius\\matching-ui\\src\\Matching\\PopUp.js",["69","70"],"import React from 'react';\r\nimport Grid from \"@material-ui/core/Grid\";\r\nimport {Modal, Radio} from \"antd\";\r\n\r\n/**\r\n * Creates PopUp (Modal) for an outputProperty, to show matching suggestions for it.\r\n * If matching suggestions available, PopUp shows three suggestions, which input property can be matched with the output property.\r\n * Else PopUp shows that tell that no matching suggestions are available.\r\n * Also sort the suggestion property to the outputProperty.\r\n */\r\nexport default class PopUp extends React.Component{\r\n    /**\r\n     * {Integer} outputRowIndex row index of the selected outputProperty\r\n     * {String} outputPropertyName name of the selected outputProperty\r\n     * {String} radioValue contains the value of the selected radio button\r\n     * {Object[]} matchingSuggestions contains for every output property the 3 best suggestions of input properties to match\r\n     * {Object[]} assignedGridData contains the properties that are shown in the middle Table/Grid in {@link AssignmentTables}\r\n     * {Object} popUpSuggestions contains the three matching suggestion for the selected outputProperty (name and value)\r\n     * {Object} popUpSuggestionsNotifications when an matching suggestion is already assigned, it contains a note with the index where it is assigned\r\n     * {boolean} showPopUp is true if suggestion PopUp should be shown and false if its should be hidden\r\n     * {boolean} showNote is true if Note PopUp is shown and false if not\r\n     */\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            outputRowIndex: -1,\r\n            outputPropertyName: \"\", radioValue: \"\",\r\n            matchingSuggestions: [],\r\n            assignedGridData: [],\r\n            popUpSuggestions: {suggestionOne: {name: \"\", value: 0.0}, suggestionTwo: {name: \"\", value: 0.0}, suggestionThree: {name: \"\", value: 0.0}},\r\n            popUpSuggestionsNotifications: {suggestionOne: \"\", suggestionTwo: \"\", suggestionThree: \"\"},\r\n            showPopUp: false, showNote: false,\r\n        }\r\n\r\n        this.closePopUp = this.closePopUp.bind(this);\r\n        this.closeNote = this.closeNote.bind(this);\r\n        this.handleButtonClick = this.handleButtonClick.bind(this);\r\n        this.handleRadioButtonChoice = this.handleRadioButtonChoice.bind(this);\r\n    }\r\n\r\n    /**\r\n     * Sets {@link outputRowIndex}, {@link outputPropertyName}, {@link matchingSuggestions} and {@link assignedGridData}.\r\n     * If for selected outputProperty is no matching suggestion available, show Note PopUp, else show suggestion PopUp.\r\n     */\r\n    async updatePopUp(){\r\n        let suggestionsAvailable = false;\r\n\r\n        await this.setState({outputRowIndex: this.props.popUpInformation.outputRowIndex, outputPropertyName: this.props.popUpInformation.outputPropertyName,\r\n            matchingSuggestions: this.props.popUpInformation.matchingSuggestions, assignedGridData: this.props.popUpInformation.assignedGridData});\r\n\r\n        Object.keys(this.state.matchingSuggestions).map((listIndex) =>{\r\n            let outputPropertySuggestions = this.state.matchingSuggestions[listIndex][this.state.outputPropertyName];\r\n\r\n            if(outputPropertySuggestions !== \"noSimilarity\"){\r\n                suggestionsAvailable = true;\r\n            }\r\n        })\r\n\r\n        if(suggestionsAvailable){\r\n            this.setState({showPopUp: true});\r\n        }\r\n        else {\r\n            this.setState({showNote: true})\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If suggestion PopUp shown and props changed, calls {@link updatePopUp}.\r\n     *\r\n     * @param prevProps like the definition\r\n     * @param prevState like the definition\r\n     * @param snapshot like the definition\r\n     */\r\n    componentDidUpdate(prevProps: Readonly<P>, prevState: Readonly<S>, snapshot: SS) {\r\n        if(this.props.showPopUp && prevProps !== this.props){\r\n            this.updatePopUp();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Event handler.\r\n     * Select with radio button selection, the list in {@link matchingSuggestions}, where the suggestion for selected outputProperty comes from.\r\n     * Calculates names and values of the suggestions and saves them (one to three suggestions possible).\r\n     * If suggestions already assigned, {@link popUpSuggestionsNotifications} saves a note with the index.\r\n     *\r\n     * @param args contains information about the selected radio button\r\n     */\r\n    handleRadioButtonChoice(args){\r\n        console.log(args);\r\n        this.setState({radioValue: args.target.value});\r\n        let propertySuggestionsArray = this.state.matchingSuggestions[args.target.value][this.state.outputPropertyName];\r\n        let propertySuggestionsObject = {suggestionOne: {name: \"\", value: 0.0}, suggestionTwo: {name: \"\", value: 0.0}, suggestionThree: {name: \"\", value: 0.0}};\r\n        let popUpSuggestionsNotifications = {suggestionOne: \"\", suggestionTwo: \"\", suggestionThree: \"\"};\r\n        let popUpNamesArray = [\"suggestionOne\", \"suggestionTwo\", \"suggestionThree\"];\r\n\r\n        if(typeof propertySuggestionsArray === \"string\"){\r\n            let splitSuggestion = propertySuggestionsArray.split(\"|\");\r\n\r\n            propertySuggestionsObject[\"suggestionOne\"] = {name: splitSuggestion[0], value: splitSuggestion[1]};\r\n        }\r\n        else {\r\n            for (let i = 0; i < propertySuggestionsArray.length; i++) {\r\n                let splitSuggestion = propertySuggestionsArray[i].split(\"|\");\r\n\r\n                propertySuggestionsObject[popUpNamesArray[i]] = {name: splitSuggestion[0], value: splitSuggestion[1]};\r\n            }\r\n        }\r\n\r\n        this.state.assignedGridData.map((item, index) => {\r\n            if(item.name !== \"\"){\r\n                if(item.name === propertySuggestionsObject.suggestionOne.name){\r\n                    popUpSuggestionsNotifications.suggestionOne = \"Hinweis: schon in Zeile \" + index + \" zugeordnet\";\r\n                }\r\n\r\n                if(item.name === propertySuggestionsObject.suggestionTwo.name){\r\n                    popUpSuggestionsNotifications.suggestionTwo = \"Hinweis: schon in Zeile \" + index + \" zugeordnet\";\r\n                }\r\n\r\n                if(item.name === propertySuggestionsObject.suggestionThree.name){\r\n                    popUpSuggestionsNotifications.suggestionThree = \"Hinweis: schon in Zeile \" + index + \" zugeordnet\";\r\n                }\r\n            }\r\n        });\r\n\r\n        this.setState({popUpSuggestions: propertySuggestionsObject,\r\n            popUpSuggestionsNotifications: popUpSuggestionsNotifications});\r\n    }\r\n\r\n    /**\r\n     * Resets {@link popUpSuggestions} and {@link popUpSuggestionsNotifications}.\r\n     */\r\n    resetPopUp(){\r\n        let popUpSuggestions = {suggestionOne: {name: \"\", value: 0.0}, suggestionTwo: {name: \"\", value: 0.0}, suggestionThree: {name: \"\", value: 0.0}};\r\n        let popUpSuggestionsNotifications = {suggestionOne: \"\", suggestionTwo: \"\", suggestionThree: \"\"};\r\n\r\n        this.setState({popUpSuggestions: popUpSuggestions, popUpSuggestionsNotifications: popUpSuggestionsNotifications});\r\n    }\r\n\r\n    /**\r\n     * Event handler.\r\n     * If suggestion is clicked, hides suggestion PopUp and calls {@link MatchingView.handleSuggestionClick}.\r\n     * Calls {@link resetPopUp} and unselect radio buttons.\r\n     *\r\n     * @param args contains the information about the clicked button\r\n     */\r\n    handleButtonClick(args){\r\n        if(args.nativeEvent.target.name !== \"\") {\r\n            this.setState({showPopUp: false});\r\n            this.props.handleSuggestionClick(args.nativeEvent.target.name);\r\n        }\r\n        this.resetPopUp();\r\n        this.setState({radioValue: \"\"});\r\n    }\r\n\r\n    /**\r\n     * Hides the suggestion PopUp and unselect radio buttons.\r\n     */\r\n    closePopUp(){\r\n        this.resetPopUp();\r\n        this.setState({showPopUp: false});\r\n        this.setState({radioValue: \"\"});\r\n    }\r\n\r\n    /**\r\n     * Hides the Note PopUp and unselect radio buttons.\r\n     */\r\n    closeNote(){\r\n        this.resetPopUp();\r\n        this.setState({showNote: false});\r\n        this.setState({radioValue: \"\"});\r\n    }\r\n\r\n    /**\r\n     * Contains two PopUp components.\r\n     * If matching suggestions are available, the suggestion PopUp shows.\r\n     * The suggestion PopUp contains three Button components, which display matching suggestions (output properties) for input component.\r\n     * The suggestion PopUp contains three Input components (readOnly), which shows how similar output and input properties are to each other.\r\n     * The suggestion PopUp contains three Input components (readOnly), which shows when a suggestion is already assigned (shows also on which index).\r\n     * If {@link showPopUp} is true, updates suggestions and notifications of suggestion PopUp and shows it.\r\n     * If no matching suggestions are available, the note PopUp shows.\r\n     * The note PopUp contains the information, that no suggestion are available.\r\n     */\r\n    render() {\r\n        const screenHeight = window.innerHeight, screenWidth = window.innerWidth;\r\n        let suggestionOne = this.state.popUpSuggestions.suggestionOne.name;\r\n        let suggestionTwo = this.state.popUpSuggestions.suggestionTwo.name;\r\n        let suggestionThree = this.state.popUpSuggestions.suggestionThree.name;\r\n\r\n        const popUpStyle = {\r\n            minHeight: screenHeight * 0.4,\r\n            maxHeight: screenHeight * 0.4,\r\n            minWidth: screenWidth * 0.65,\r\n            maxWidth: screenWidth * 0.65,\r\n            display: \"flex\",\r\n            alignItems: \"center\",\r\n        }\r\n        const popUpButtonStyle = {\r\n            minHeight: screenHeight * 0.05,\r\n            maxHeight: screenHeight * 0.05,\r\n            minWidth: screenWidth * 0.2,\r\n            maxWidth: screenWidth * 0.2\r\n        }\r\n        const popUpTextStyle = {\r\n            minHeight: screenHeight * 0.05,\r\n            maxHeight: screenHeight * 0.05,\r\n            minWidth: screenWidth * 0.2,\r\n            maxWidth: screenWidth * 0.2,\r\n            border: \"none\",\r\n            textAlign: \"center\",\r\n        }\r\n        const popUpNotificationTextStyle = {\r\n            minHeight: screenHeight * 0.05,\r\n            maxHeight: screenHeight * 0.05,\r\n            minWidth: screenWidth * 0.2,\r\n            maxWidth: screenWidth * 0.2,\r\n            border: \"none\",\r\n            textAlign: \"center\",\r\n            color: \"red\"\r\n        }\r\n        const noteStyle = {\r\n            minHeight: screenHeight * 0.1,\r\n            maxHeight: screenHeight * 0.1,\r\n            minWidth: screenWidth * 0.15,\r\n            maxWidth: screenWidth * 0.15,\r\n        }\r\n        const noteText = {\r\n            height: screenHeight*0.05,\r\n            width: screenWidth*0.13,\r\n            border: \"none\",\r\n            textAlign: \"center\",\r\n        }\r\n        const radioStyle = {\r\n            alignContent:\"center\",\r\n            display:\"flex\",\r\n            justifyContent:\"center\",\r\n        }\r\n        const radioTextStyle = {\r\n            minHeight: screenHeight * 0.05,\r\n            maxHeight: screenHeight * 0.05,\r\n            minWidth: screenWidth * 0.2,\r\n            maxWidth: screenWidth * 0.2,\r\n            border: \"none\",\r\n            textAlign: \"center\",\r\n            fontSize: \"20px\",\r\n            textDecoration: \"underline\",\r\n        }\r\n\r\n        return(\r\n            <div>\r\n                <div>\r\n                    <Modal style={popUpStyle} className={\"suggestion PopUp\"} title={\"Matching-Suggestions\"} visible={this.state.showPopUp} onCancel={this.closePopUp} maskClosable={true} footer={null}>\r\n                        <div>\r\n                            <Grid container spacing={1} style={radioStyle}>\r\n                                <Grid item>\r\n                                    <input style={radioTextStyle} value={\"Choice of similarity methods\"} readOnly={true}/>\r\n                                </Grid>\r\n                            </Grid>\r\n                            <Grid container spacing={1} style={radioStyle}>\r\n                                <Grid item>\r\n                                    <Radio.Group onChange={this.handleRadioButtonChoice} size={\"middle\"} value={this.state.radioValue}>\r\n                                        <Radio.Button value={\"jaroWinkler\"}>Jaro Winkler</Radio.Button>\r\n                                        <Radio.Button value={\"jaccard\"}>Jaccard</Radio.Button>\r\n                                        <Radio.Button value={\"normLevenshtein\"}>norm. Levenshtein</Radio.Button>\r\n                                        <Radio.Button value={\"average\"}>Average</Radio.Button>\r\n                                        <Radio.Button value={\"min\"}>Minimum</Radio.Button>\r\n                                        <Radio.Button value={\"max\"}>Maximum</Radio.Button>\r\n                                        <Radio.Button disabled={true} value={\"user\"}>User-Matching</Radio.Button>\r\n                                    </Radio.Group>\r\n                                </Grid>\r\n                            </Grid>\r\n                            <br/>\r\n                            <Grid container spacing={1} alignItems={\"center\"}>\r\n                                <Grid item>\r\n                                    <button name={suggestionOne} onClick={this.handleButtonClick} style={popUpButtonStyle}>{suggestionOne}</button>\r\n                                </Grid>\r\n                                <Grid item>\r\n                                    <button name={suggestionTwo} onClick={this.handleButtonClick} style={popUpButtonStyle}>{suggestionTwo}</button>\r\n                                </Grid>\r\n                                <Grid item>\r\n                                    <button name={suggestionThree} onClick={this.handleButtonClick} style={popUpButtonStyle}>{suggestionThree}</button>\r\n                                </Grid>\r\n                            </Grid>\r\n                            <Grid container spacing={1} alignItems={\"center\"}>\r\n                                <Grid item>\r\n                                    <input style={popUpTextStyle} value={\"Übereinstimmung: \" + this.state.popUpSuggestions.suggestionOne.value*100 + \"%\"} readOnly={true}/>\r\n                                </Grid>\r\n                                <Grid item>\r\n                                    <input style={popUpTextStyle} value={\"Übereinstimmung: \" + this.state.popUpSuggestions.suggestionTwo.value*100 + \"%\"} readOnly={true}/>\r\n                                </Grid>\r\n                                <Grid item>\r\n                                    <input style={popUpTextStyle} value={\"Übereinstimmung: \" + this.state.popUpSuggestions.suggestionThree.value*100 + \"%\"} readOnly={true}/>\r\n                                </Grid>\r\n                            </Grid>\r\n                            <Grid container spacing={1} alignItems={\"center\"}>\r\n                                <Grid item>\r\n                                    <input style={popUpNotificationTextStyle} value={this.state.popUpSuggestionsNotifications.suggestionOne} readOnly={true}/>\r\n                                </Grid>\r\n                                <Grid item>\r\n                                    <input style={popUpNotificationTextStyle} value={this.state.popUpSuggestionsNotifications.suggestionTwo} readOnly={true}/>\r\n                                </Grid>\r\n                                <Grid item>\r\n                                    <input style={popUpNotificationTextStyle} value={this.state.popUpSuggestionsNotifications.suggestionThree} readOnly={true}/>\r\n                                </Grid>\r\n                            </Grid>\r\n                        </div>\r\n                    </Modal>\r\n                </div>\r\n                <div>\r\n                    <Modal className={\"note PopUp\"} style={noteStyle} visible={this.state.showNote} onCancel={this.closeNote} maskClosable={true} closable={false} footer={[<button onClick={this.closeNote}>OK</button>]}>\r\n                        <input style={noteText} value={\"No matching suggestions available.\"} readOnly={true}/>\r\n                    </Modal>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","C:\\Users\\Max\\Desktop\\BA GitLab\\bachelorarbeit-max-moebius\\matching-ui\\src\\Matching\\AssignmentTables.js",["71","72","73","74"],"import React, {createRef, useCallback} from 'react';\r\nimport Grid from \"@material-ui/core/Grid\";\r\nimport {CloseOutlined, QuestionOutlined} from \"@ant-design/icons\";\r\nimport { AgGridColumn, AgGridReact } from 'ag-grid-react';\r\n\r\n/**\r\n * Creates three Grid/Table components.\r\n * There you can assign input properties to output properties with drag and drop.\r\n */\r\nexport default class AssignmentTables extends React.Component{\r\n    /**\r\n     * {Object} processedInputObject contains data of selected input object from input API in format to display in Grid/Table\r\n     * {Object[]} processedOutputProperties contains data of selected output object from output API in format to display in Grid/Table\r\n     * {Object} matchingSuggestions contains for every output property the 3 best suggestions of input properties to match\r\n     * {Object[]} virSatSystemModes contains the three system modes: Idle, Science and Communication with its uuid\r\n     * {Object[]} unassignedGridData contains the properties that are shown in the left Table/Grid in {@link AssignmentTables}\r\n     * {Object[]} assignedGridData contains the properties that are shown in the middle Table/Grid in {@link AssignmentTables}\r\n     * {boolean} matchingSuggestionsNotReady is false if matching suggestion are calculated by Matching API\r\n     */\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            processedInputObject: [], processedOutputProperties: [], partDatProperties: [],\r\n            matchingSuggestions: [],\r\n            virSatSystemModes: [\r\n                {\r\n                    name: 'Idle',\r\n                    uuid: 'edc117d5-3f51-49d0-88f2-4af154c2337a'\r\n                },\r\n                {\r\n                    name: 'Science',\r\n                    uuid: 'c5b9b806-6845-4c64-86d9-06115674c2f0'\r\n                },\r\n                {\r\n                    name: 'Communication',\r\n                    uuid: '571bb5c1-b56a-4813-8a95-4ad6280e216f'\r\n                }\r\n            ],\r\n            unassignedGridData: [], assignedGridData: [],\r\n            matchingSuggestionsNotReady: true,\r\n        }\r\n\r\n        this.returnClick = this.returnClick.bind(this);\r\n        this.handleRowDropToAssignedGrid = this.handleRowDropToAssignedGrid.bind(this);\r\n        this.handleRowDropToUnassignedGrid = this.handleRowDropToUnassignedGrid.bind(this);\r\n        this.processRowDragAndDrop = this.processRowDragAndDrop.bind(this);\r\n        this.handleSuggestionClick = this.handleSuggestionClick.bind(this);\r\n        this.handleScrollAssignedAndOutput = this.handleScrollAssignedAndOutput.bind(this);\r\n    }\r\n\r\n    /**\r\n     * Searches for a inputProperty the right unit (if a property have a unit).\r\n     *\r\n     * @param propItemName contains the name of the property of the inputObject\r\n     * @param partDatProperties contains all information about the properties of the Part Database\r\n     * @returns {string|*} the unit of the property or empty string\r\n     */\r\n    calculatePropertyUnit(propItemName, partDatProperties){\r\n        for (let property of partDatProperties)\r\n        {\r\n            if(propItemName === property.identifier){\r\n                if(property.unit === undefined){\r\n                    return \"\";\r\n                }\r\n                else {\r\n                    return property.unit;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Goes through all properties recursive (if a properties contains Object[] as value).\r\n     * Calculates for every property their unit with {@link calculatePropertyUnit}.\r\n     * If property has no parent, usually adds name, value and the unit of a property into list.\r\n     * Else add parents name + name of the property, value and the unit of the property into list.\r\n     *\r\n     * @param {Object[]} inputProperties contains all properties of input object\r\n     * @param partDatProperties contains all information about the properties of the Part Database\r\n     * @param {Object[]} processedInputProperties contains all properties of input object in format to display in Table\r\n     * @param {String} parentName contains the names of one or more parents, separated by dot\r\n     */\r\n    processInputPropertyData(inputProperties, partDatProperties, processedInputProperties, parentName){\r\n        const typeObject = \"object\";\r\n\r\n        if(parentName === \"\"){\r\n            for (let propItemName of Object.keys(inputProperties)) {\r\n                let propertyUnit = this.calculatePropertyUnit(propItemName, partDatProperties);\r\n\r\n                if(inputProperties[propItemName] === null){\r\n                    processedInputProperties.push({name: propItemName, value: inputProperties[propItemName], unit: propertyUnit});\r\n                }\r\n                else if( typeof inputProperties[propItemName] === typeObject){\r\n                    this.processInputPropertyData(inputProperties[propItemName], partDatProperties, processedInputProperties, propItemName);\r\n                }\r\n                else {\r\n                    processedInputProperties.push({name: propItemName, value: inputProperties[propItemName], unit: propertyUnit});\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (let propItemName of Object.keys(inputProperties)) {\r\n                let propertyUnit = this.calculatePropertyUnit(propItemName, partDatProperties);\r\n\r\n                if(inputProperties[propItemName] === null){\r\n                    processedInputProperties.push({name: parentName + \".\" + propItemName, value: inputProperties[propItemName], unit: propertyUnit});\r\n                }\r\n                else if( typeof inputProperties[propItemName] === typeObject){\r\n                    this.processInputPropertyData(inputProperties[propItemName], partDatProperties, processedInputProperties, parentName + \".\" + propItemName);\r\n                }\r\n                else {\r\n                    processedInputProperties.push({name: parentName + \".\" + propItemName, value: inputProperties[propItemName], unit: propertyUnit});\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Goes through the mode values (they contain no names, only uuid).\r\n     * Calculates with \"this.state.virSatSystemModes\" and uuid of a mode the name.\r\n     * Add name (property + mode), value and unit to list.\r\n     *\r\n     * @param {String} outputPropertyName contains the name of the output property\r\n     * @param {Object[]} modeValues\r\n     * @param {Object[]} processedOutputProperties contains all properties of output object in format to display in Table\r\n     */\r\n    processOutputPropertyWithModes(outputPropertyName, modeValues, processedOutputProperties){\r\n        for (let modeItem of modeValues) {\r\n            let modeName = this.state.virSatSystemModes.filter(mode => mode.uuid === modeItem.value.mode)[0].name;\r\n\r\n            processedOutputProperties.push({name: outputPropertyName + modeName, value: modeItem.value.valueBean.value, unit: modeItem.value.valueBean.unit});\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Saves name, value and unit of property in list.\r\n     * If defaultValueBean is undefined, just add the name, value and unit.\r\n     * If modeValuesBean is empty, add name and value and unit.\r\n     * Else modeValuesBean is not empty, so call {@link processOutputPropertyWithModes} with the mode values.\r\n     *\r\n     * @param {String} outputPropertyName contains the name of the output property\r\n     * @param {Object} outputProperty contains data of the output property\r\n     * @param {Object[]} processedOutputProperties contains all properties of output object in format to display in Table\r\n     */\r\n    processOutputProperty(outputPropertyName, outputProperty, processedOutputProperties){\r\n        if(outputProperty.defaultValueBean === undefined){\r\n            processedOutputProperties.push({name: outputPropertyName, value: outputProperty.value, unit: outputProperty.unit});\r\n        }\r\n        else if(outputProperty.modeValuesBean.length === 0){\r\n            processedOutputProperties.push({name: outputPropertyName, value: outputProperty.defaultValueBean.value, unit: outputProperty.defaultValueBean.unit});\r\n        }\r\n        else {\r\n            let modeValues = outputProperty.modeValuesBean;\r\n\r\n            this.processOutputPropertyWithModes(outputPropertyName, modeValues, processedOutputProperties);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Goes through every category assignment of the outputObject and extract the properties.\r\n     * Calls for every property of  {@link processOutputProperty}.\r\n     *\r\n     * @param {Object[]} processedOutputProperties contains all properties of output object in format to display in Table\r\n     */\r\n    async processOutputObjectProperties(processedOutputProperties) {\r\n        let outputObjectCatAssignments = [];\r\n        const parameters = \"Parameters\";\r\n        const visualisation = \"Visualisation\";\r\n        const typeObject = \"object\";\r\n\r\n        await Promise.all(this.props.outputObjectFromAPI.categoryAssignments.map(async (item) => {\r\n            let name = item.name;\r\n            const categoryAssignmentURL = \"http://localhost:8000/rest/model/v0.0.1/repository/KatSatCEF/ca/\" + item.uuid\r\n\r\n            if (name.includes(parameters) || name.includes(visualisation)) {\r\n                let response = await fetch(categoryAssignmentURL);\r\n\r\n                outputObjectCatAssignments.push(await response.json());\r\n            }\r\n        }))\r\n\r\n        outputObjectCatAssignments.map((arrItem) => {\r\n            if (arrItem !== undefined) {\r\n                Object.keys(arrItem).map((entryItemName) => {\r\n                    if (typeof arrItem[entryItemName] === typeObject) {\r\n                        this.processOutputProperty(entryItemName, arrItem[entryItemName], processedOutputProperties);\r\n                    }\r\n                })\r\n            }\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Processes data from input and output object to display it in Tables.\r\n     * Also fetch all properties from \"Part Database API\".\r\n     * Does matching request with input object, output object and part database properties (PUT request with input).\r\n     */\r\n    async processApiData() {\r\n        let inputObjectFromAPI = this.props.inputObjectFromAPI;\r\n        let processedInputProperties = [];\r\n        const getPartDatPropertiesURL = \"http://localhost:9000/api/properties/\";\r\n\r\n        const responsePartDatProperties = await fetch(getPartDatPropertiesURL);\r\n        const partDatProperties = await responsePartDatProperties.json();\r\n        this.setState({partDatProperties: partDatProperties})\r\n\r\n        this.processInputPropertyData(inputObjectFromAPI.properties, partDatProperties, processedInputProperties, \"\");\r\n\r\n        inputObjectFromAPI.properties = processedInputProperties;\r\n        this.setState({processedInputObject: inputObjectFromAPI, unassignedGridData: processedInputProperties});\r\n\r\n        let processedOutputProperties = [];\r\n\r\n        await this.processOutputObjectProperties(processedOutputProperties);\r\n\r\n        let assignedGridData = new Array(processedOutputProperties.length).fill({name: \"\", value: \"\", unit: \"\"});\r\n        this.setState({processedOutputProperties: processedOutputProperties, assignedGridData: assignedGridData});\r\n\r\n        let jsons = {\r\n            inputObjectData: this.state.processedInputObject,\r\n            outputObjectData: this.state.processedOutputProperties,\r\n        };\r\n\r\n        const responseMatchingSuggestions = await fetch(\"http://localhost:8080/json\",{\r\n            method:\"PUT\",\r\n            headers:{\r\n                \"Accept\":\"application/json\",\r\n                \"Content-Type\":\"application/json\"\r\n            },\r\n            body:JSON.stringify(jsons)\r\n        });\r\n\r\n        this.props.matchingSuggestions(JSON.parse(await responseMatchingSuggestions.text()));\r\n        this.setState({matchingSuggestionsNotReady: false});\r\n        this.outputGrid.api.refreshCells({force: true});\r\n    }\r\n\r\n    /**\r\n     * Searches inside the unassigned data (left Table) for target name.\r\n     * If target name is inside, name and value got added to assigned data and removed from unassigned data.\r\n     * The index where it is assigned, is the index of the output property you search an matching suggestion for.\r\n     *\r\n     * @param {Object[]} unassignedData contains all input properties which are not assigned to output properties (in left table)\r\n     * @param {String} targetName name of input property that should be assigned to output property\r\n     * @param {Object[]} assignedData contains all input properties which are assigned to output properties (in left table)\r\n     * @returns {boolean} if target name was in unassigned data, its true\r\n     */\r\n    searchTargetInUnassigned(unassignedData, targetName, assignedData) {\r\n        let property = {};\r\n        let foundInUnassignedData = false;\r\n\r\n        for (let i = 0; i < unassignedData.length; i++) {\r\n            if (unassignedData[i].name === targetName) {\r\n                property = unassignedData[i];\r\n                unassignedData[i] = assignedData[this.props.outputRowIndex];\r\n                assignedData[this.props.outputRowIndex] = property;\r\n\r\n                foundInUnassignedData = true;\r\n                break;\r\n            }\r\n        }\r\n        return foundInUnassignedData;\r\n    }\r\n\r\n    /**\r\n     * Searches inside the unassigned data (left Table) for target name.\r\n     * If target name is inside, name and value changes just the index.\r\n     * If on the index is already an property, the old property moves to unassigned data and the new changes index.\r\n     *\r\n     * @param {boolean} foundInUnassignedData is true if target name is already in unassigned data\r\n     * @param {Object[]} assignedData contains all input properties which are assigned to output properties (in left table)\r\n     * @param {String} targetName name of input property that should be assigned to output property\r\n     * @param {Object[]} unassignedData contains all input properties which are not assigned to output properties (in left table)\r\n     */\r\n    searchTargetInAssigned(foundInUnassignedData, assignedData, targetName, unassignedData) {\r\n        let property = {};\r\n\r\n        if (!foundInUnassignedData) {\r\n            for (let i = 0; i < assignedData.length; i++) {\r\n                if (assignedData[i].name === targetName) {\r\n                    property = assignedData[i];\r\n                    assignedData[i] = {name: \"\", value: \"\"};\r\n\r\n                    for (let i = 0; i < unassignedData.length; i++) {\r\n                        if (unassignedData[i].name === \"\") {\r\n                            unassignedData[i] = assignedData[this.props.outputRowIndex];\r\n                            break;\r\n                        }\r\n                    }\r\n                    assignedData[this.props.outputRowIndex] = property;\r\n\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the properties to the top of the grid.\r\n     *\r\n     * @param gridData contains the properties of a Grid/Table\r\n     */\r\n    reorderGridToTop(gridData){\r\n        for (let i = 0; i < gridData.length; i++) {\r\n            if (gridData[i].name === \"\") {\r\n                for (let j = i; j < gridData.length; j++) {\r\n                    if (gridData[j].name !== \"\") {\r\n                        gridData[i] = gridData[j];\r\n                        gridData[j] = {name: \"\", value: \"\"};\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calls if suggestion {@link PopUp} is selected\r\n     * Searches for target name in unassigned data and/or assigned data.\r\n     * Adds property with the target name to chosen index in assigned data (assigned to a output property).\r\n     * Calls {@link reorderGridToTop}.\r\n     * Refreshing data of {@link unassignedGrid}  and \"assignedGrid\" and resize them.\r\n     * {@link this.props.resetSuggestions} resets the selected matching suggestion.\r\n     *\r\n     * @param {String} targetName name of input property that should be assigned to output property\r\n     */\r\n    handleSuggestionClick(targetName){\r\n        let unassignedData = this.state.unassignedGridData;\r\n        let assignedData = this.state.assignedGridData;\r\n\r\n        let foundInUnassignedData = this.searchTargetInUnassigned(unassignedData, targetName, assignedData);\r\n\r\n        this.searchTargetInAssigned(foundInUnassignedData, assignedData, targetName, unassignedData);\r\n\r\n        this.reorderGridToTop(this.state.unassignedGridData);\r\n\r\n        this.unassignedGrid.api.setRowData(unassignedData);\r\n        this.assignedGrid.api.setRowData(assignedData);\r\n\r\n        this.unassignedGrid.api.refreshCells({force: true});\r\n        this.assignedGrid.api.refreshCells({force: true});\r\n\r\n        this.unassignedGrid.columnApi.autoSizeAllColumns();\r\n        this.assignedGrid.columnApi.autoSizeAllColumns();\r\n\r\n        this.props.resetSuggestions();\r\n    }\r\n\r\n    /**\r\n     * If props changes and input object data not set, calls {@link processApiData}.\r\n     * If props changes and in {@link PopUp} suggestion ist selected, calls {@link handleSuggestionClick}.\r\n     * Calls {@link dataToBeMatched} when {@link saveButtonClicked} changed.\r\n     * If all three grids are available, the get resize to there data.\r\n     *\r\n     * @param prevProps like in definition\r\n     * @param prevState like in definition\r\n     * @param snapshot like in definition\r\n     */\r\n    componentDidUpdate(prevProps: Readonly<P>, prevState: Readonly<S>, snapshot: SS) {\r\n        if(prevProps !== this.props) {\r\n            if(this.state.processedInputObject.length === 0){\r\n                this.processApiData();\r\n            }\r\n            if(this.props.selectedSuggestionName !== \"\"){\r\n                this.handleSuggestionClick(this.props.selectedSuggestionName);\r\n            }\r\n        }\r\n\r\n        if(this.props.saveButtonClicked !== prevProps.saveButtonClicked){\r\n            this.props.dataToBeMatched(this.state.assignedGridData, this.state.processedOutputProperties)\r\n        }\r\n\r\n        if(this.unassignedGrid && this.assignedGrid && this.outputGrid){\r\n            this.unassignedGrid.columnApi.autoSizeAllColumns();\r\n            this.assignedGrid.columnApi.autoSizeAllColumns();\r\n            this.outputGrid.columnApi.autoSizeAllColumns();\r\n            this.unassignedGrid.api.addRowDropZone(this.assignedGrid.api.getRowDropZoneParams());\r\n            this.assignedGrid.api.addRowDropZone(this.unassignedGrid.api.getRowDropZoneParams());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes dragged property from origGrid and add to the dropped row in destGrid.\r\n     * Than reorder the unassignedGrid data to top.\r\n     *\r\n     * @param {Object} args contains information about the drag and drop event\r\n     * @param origGrid reference to Grid component where the property is dragged from\r\n     * @param destGrid  reference to Grid component where the property is dropped in\r\n     */\r\n    transferRowProperty(args, origGrid, destGrid) {\r\n        let dataSourceName = {unassignedGrid: \"unassignedGridData\", assignedGrid: \"assignedGridData\"};\r\n        let origData = this.state[dataSourceName[origGrid.props.id]], destData = this.state[dataSourceName[destGrid.props.id]];\r\n        let closestRowIndex = args.overIndex;\r\n        const unassignedGridDataName = \"unassignedGridData\";\r\n\r\n        if (destData[closestRowIndex].name === \"\") {\r\n            destData[closestRowIndex] = origData[args.node.id];\r\n            origData[args.node.id] = {name: \"\", value: \"\"};\r\n        } else {\r\n            let rowData = destData[closestRowIndex];\r\n            destData[closestRowIndex] = origData[args.node.id];\r\n            origData[args.node.id] = rowData;\r\n        }\r\n\r\n        if (dataSourceName[origGrid.props.id] === unassignedGridDataName) {\r\n            this.reorderGridToTop(origData);\r\n        } else if (dataSourceName[destGrid.props.id] === unassignedGridDataName) {\r\n            this.reorderGridToTop(destData);\r\n        }\r\n\r\n        if(origGrid !== destGrid){\r\n            origGrid.api.setRowData(origData);\r\n            destGrid.api.setRowData(destData);\r\n        }\r\n        else {\r\n            destGrid.api.setRowData(destData);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transfer with {@link transferRowProperty} property from dragged row to dropped row.\r\n     * Refreshing data of unassignedGrid and assignedGrid and resize them.\r\n     *\r\n     * @param {Object} args contains information about the drag and drop event\r\n     * @param origGrid reference to Grid component where the property is dragged from\r\n     * @param destGrid reference to Grid component where the property is dropped in\r\n     */\r\n    processRowDragAndDrop(args, origGrid, destGrid){\r\n        this.transferRowProperty(args, origGrid, destGrid);\r\n\r\n        origGrid.api.refreshCells({force: true});\r\n        destGrid.api.refreshCells({force: true});\r\n\r\n        origGrid.columnApi.autoSizeAllColumns();\r\n        destGrid.columnApi.autoSizeAllColumns();\r\n    }\r\n\r\n    /**\r\n     * Event handler.\r\n     * Check if its drag and drop from extern or the same grid.\r\n     * Calls {@link processRowDragAndDrop} with references to the grid components, first is origin and second is destination.\r\n     *\r\n     * @param {Object} args contains information about the drag and drop event\r\n     */\r\n    handleRowDropToAssignedGrid(args){\r\n        if(this.unassignedGrid.api === args.node.gridApi){\r\n            this.processRowDragAndDrop(args, this.unassignedGrid, this.assignedGrid);\r\n        }\r\n        else {\r\n            this.processRowDragAndDrop(args, this.assignedGrid, this.assignedGrid);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Event handler\r\n     * Check if its drag and drop from extern or the same grid.\r\n     * Calls {@link processRowDragAndDrop} with references to the grid components, first is origin and second is destination.\r\n     *\r\n     * @param {Object} args contains information about the drag and drop event\r\n     */\r\n    handleRowDropToUnassignedGrid(args){\r\n        if(this.assignedGrid.api === args.node.gridApi){\r\n            this.processRowDragAndDrop(args, this.assignedGrid, this.unassignedGrid);\r\n        }\r\n        else {\r\n            this.processRowDragAndDrop(args, this.unassignedGrid, this.unassignedGrid);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Event handler\r\n     * Removes property from the row of the clicked button back to unassigned Grid.\r\n     * Refreshes unassigned and assigned Grid and resize them.\r\n     *\r\n     * @param {Object} args contains information about the row where the button was pressed.\r\n     */\r\n    async returnClick(args){\r\n        if(args.data.name === \"\") {\r\n            return;\r\n        }\r\n\r\n        let unassignedData = this.state.unassignedGridData;\r\n        let assignedData = this.state.assignedGridData;\r\n        let closestRowIndex = args.rowIndex;\r\n\r\n        for (let i = 0; i < unassignedData.length; i++) {\r\n            if (unassignedData[i].name === \"\") {\r\n                unassignedData[i] = args.data;\r\n                break;\r\n            }\r\n        }\r\n\r\n        assignedData[closestRowIndex] = {name: \"\", value: \"\"};\r\n\r\n        this.unassignedGrid.api.setRowData(unassignedData);\r\n        this.assignedGrid.api.setRowData(assignedData);\r\n\r\n        this.unassignedGrid.api.refreshCells({force: true});\r\n        this.assignedGrid.api.refreshCells({force: true});\r\n\r\n        this.unassignedGrid.columnApi.autoSizeAllColumns();\r\n        this.assignedGrid.columnApi.autoSizeAllColumns();\r\n    }\r\n\r\n    /**\r\n     * Event handler.\r\n     * Synchronize the scrollbars of assignedGrid and outputGrid, if one of them moves.\r\n     */\r\n    handleScrollAssignedAndOutput(){\r\n        let hoverComponent = document.querySelectorAll(\":hover\");\r\n\r\n        if(hoverComponent[14] === this.assignedGrid.eGridDiv.querySelector(\".ag-body-viewport\")){\r\n            this.outputGrid.eGridDiv.querySelector(\".ag-body-viewport\").scrollTop = this.assignedGrid.eGridDiv.querySelector(\".ag-body-viewport\").scrollTop\r\n        }\r\n        else if(hoverComponent[14] === this.outputGrid.eGridDiv.querySelector(\".ag-body-viewport\")){\r\n            this.assignedGrid.eGridDiv.querySelector(\".ag-body-viewport\").scrollTop = this.outputGrid.eGridDiv.querySelector(\".ag-body-viewport\").scrollTop\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Contains three Grid/Table components.\r\n     * First table (left table) shows all properties of input object, which are unassigned to properties of output object.\r\n     * Second table (middle table) is like first table, but only all assigned properties.\r\n     * Third table (right table) shows all properties of output object.\r\n     */\r\n    render() {\r\n        const screenWidth = window.innerWidth;\r\n        const screenHeight = window.innerHeight;\r\n\r\n        const gridStyle = {\r\n            height: screenHeight*0.85,\r\n            width: screenWidth*0.325,\r\n        }\r\n        const insideGridStyle = {\r\n            overflowX: \"scroll\",\r\n            overflowY: \"scroll\",\r\n        }\r\n        const buttonStyle = {\r\n            height: screenHeight*0.04,\r\n            display: \"flex\",\r\n            alignItems: \"center\",\r\n        }\r\n\r\n        const gridOptionAssigned = {\r\n            alignedGrids: []\r\n        }\r\n        const gridOptionOutput = {\r\n            alignedGrids: []\r\n        }\r\n        gridOptionAssigned.alignedGrids.push(gridOptionOutput);\r\n        gridOptionOutput.alignedGrids.push(gridOptionAssigned);\r\n\r\n        return(\r\n            <div>\r\n                <Grid container spacing={1} alignItems={\"center\"}>\r\n                    <Grid item style={gridStyle} className=\"ag-theme-alpine\">\r\n                        <AgGridReact id={\"unassignedGrid\"} ref={ref => this.unassignedGrid = ref} style={insideGridStyle} key={this.state.unassignedGridData} rowDragManaged={true}\r\n                                     rowData={this.state.processedInputObject.properties} onRowDragEnd={this.handleRowDropToUnassignedGrid} suppressMoveWhenRowDragging={true}\r\n                        suppressScrollOnNewData={true}>\r\n                            <AgGridColumn headerName={\"Parameter name\"} field={\"name\"} rowDrag={true}/>\r\n                            <AgGridColumn headerName={\"Value\"} field={\"value\"}/>\r\n                            <AgGridColumn headerName={\"Unit\"} field={\"unit\"}/>\r\n                        </AgGridReact>\r\n                    </Grid>\r\n                    <Grid item style={gridStyle} className=\"ag-theme-alpine\">\r\n                        <AgGridReact class={\"hallo\"} id={\"assignedGrid\"} style={insideGridStyle} ref={ref => this.assignedGrid = ref} key={this.state.assignedGridData} rowDragManaged={true}\r\n                                     rowData={this.state.assignedGridData} onRowDragEnd={this.handleRowDropToAssignedGrid} suppressMoveWhenRowDragging={true}\r\n                                     gridOptions={gridOptionAssigned} onBodyScroll={(params) => this.handleScrollAssignedAndOutput(params)}\r\n                                     suppressScrollOnNewData={true}>\r\n                            <AgGridColumn headerName={\"Parameter name\"} field={\"name\"} rowDrag={true}/>\r\n                            <AgGridColumn headerName={\"Value\"} field={\"value\"}/>\r\n                            <AgGridColumn headerName={\"Unit\"} field={\"unit\"}/>\r\n                            <AgGridColumn headerName={\"Delete\"} cellRendererFramework={(args) => (<button style={buttonStyle} onClick={ () => this.returnClick(args)}><CloseOutlined/></button>)}/>\r\n                        </AgGridReact>\r\n                    </Grid>\r\n                    <Grid item style={gridStyle} className=\"ag-theme-alpine\">\r\n                        <AgGridReact id={\"outputGrid\"} ref={ref => this.outputGrid = ref} style={insideGridStyle} rowData={this.state.processedOutputProperties} gridOptions={gridOptionOutput}\r\n                                     onBodyScroll={(params) => this.handleScrollAssignedAndOutput(params)} suppressScrollOnNewData={true} suppressCellSelection={true}>\r\n                            <AgGridColumn headerName={\"Parameter name\"} field={\"name\"}/>\r\n                            <AgGridColumn headerName={\"Value\"} field={\"value\"}/>\r\n                            <AgGridColumn headerName={\"Unit\"} field={\"unit\"}/>\r\n                            <AgGridColumn headerName={\"Delete\"} cellRendererFramework={(args) => (<button style={buttonStyle} disabled={this.state.matchingSuggestionsNotReady}\r\n                                                                                                          onClick={ () => this.props.suggestionClick(args, this.state.assignedGridData)}><QuestionOutlined/></button>)}/>\r\n                        </AgGridReact>\r\n                    </Grid>\r\n                </Grid>\r\n            </div>\r\n        );\r\n    }\r\n}","C:\\Users\\Max\\Desktop\\BA GitLab\\bachelorarbeit-max-moebius\\matching-ui\\src\\Matching\\SaveMatchingButton.js",["75","76","77","78"],"import React from 'react';\r\nimport {Modal} from \"antd\";\r\n\r\n/**\r\n * Creates a button and notification PopUp to save an finished matching inside the\r\n * output API and matched pairs in Matching API.\r\n */\r\nexport default class SaveMatchingButton extends React.Component{\r\n    /**\r\n     * {boolean} showNote is true if Note PopUp is shown and false if not\r\n     * {Object[]} matchedData contains outputProperty names with values\r\n     */\r\n    constructor() {\r\n        super();\r\n        this.state = {\r\n            showNote: false,\r\n            matchedData: [],\r\n        }\r\n\r\n        this.handleClick = this.handleClick.bind(this);\r\n        this.saveMatching = this.saveMatching.bind(this);\r\n        this.closeNote = this.closeNote.bind(this);\r\n    }\r\n\r\n    /**\r\n     * Saves new value inside outputProperty.\r\n     *\r\n     * @param {String} outputPropertyName contains the name of the output property\r\n     * @param {Object} outputProperty contains data of the output property\r\n     * @param matchedDataPropertyValue contains the new value for the \"outputProperty\"\r\n     */\r\n    async processOutputProperty(outputPropertyName, outputProperty, matchedDataPropertyValue){\r\n        if(outputProperty.defaultValueBean === undefined){\r\n            outputProperty.value = matchedDataPropertyValue;\r\n        }\r\n        else if(outputProperty.modeValuesBean.length === 0){\r\n            outputProperty.defaultValueBean.value = matchedDataPropertyValue;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Goes through every category assignment of the outputObject and extract the properties.\r\n     * If in \"matchedData\" is a propertyName that is the same as a property name of outputObject,\r\n     * calls {@link processOutputProperty} with the new value for the property inside \"matchedData\".\r\n     * Than PUT request is provided, to save properties with new values in the object in the output API.\r\n     *\r\n     * @param {Object[]} matchedData matchedData contains outputProperty names with values\r\n     */\r\n    async processOutputObjectProperties(matchedData) {\r\n        let outputObjectCatAssignments = [];\r\n        const parameters = \"Parameters\";\r\n        const visualisation = \"Visualisation\";\r\n        const typeObject = \"object\";\r\n\r\n        await Promise.all(this.props.outputObjectFromAPI.categoryAssignments.map(async (item) => {\r\n            let name = item.name;\r\n            const categoryAssignmentURL = \"http://localhost:8000/rest/model/v0.0.1/repository/KatSatCEF/ca/\" + item.uuid\r\n\r\n            if (name.includes(parameters) || name.includes(visualisation)) {\r\n                let response = await fetch(categoryAssignmentURL);\r\n\r\n                outputObjectCatAssignments.push(await response.json());\r\n            }\r\n        }))\r\n\r\n        outputObjectCatAssignments.map(async (arrItem) => {\r\n            if (arrItem !== undefined) {\r\n                Object.keys(arrItem).map((entryItemName) => {\r\n                    let matchedDataPropertyValue = \"\";\r\n\r\n                    matchedData.filter(entry => {\r\n                        if(typeof entry.name !== \"undefined\" && entry.name === entryItemName){\r\n                            matchedDataPropertyValue = entry.value;\r\n                        }\r\n                    });\r\n\r\n                    if (typeof arrItem[entryItemName] === typeObject && matchedDataPropertyValue !== \"\") {\r\n                        this.processOutputProperty(entryItemName, arrItem[entryItemName], matchedDataPropertyValue);\r\n                    }\r\n                })\r\n            }\r\n\r\n            const responseMatching = await fetch(\"http://localhost:8000/rest/model/v0.0.1/repository/KatSatCEF/ca/\",{\r\n                method:\"PUT\",\r\n                headers:{\r\n                    \"Accept\":\"application/json\",\r\n                    \"Content-Type\":\"application/json\"\r\n                },\r\n                body:JSON.stringify(arrItem)\r\n            });\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Event handler.\r\n     * Calls {@link handleButtonClicked}.\r\n     * Shows Note PopUp.\r\n     */\r\n    handleClick(){\r\n        this.props.buttonClicked();\r\n\r\n        this.setState({showNote: true});\r\n    }\r\n\r\n    /**\r\n     * Event handler.\r\n     * Hides the Note PopUp.\r\n     */\r\n    closeNote(){\r\n        this.setState({showNote: false});\r\n    }\r\n\r\n    //aktuell werden falsche Matches einfach nur nicht übernommen\r\n    /**\r\n     * Converts the value of assignedProperty to outputProperty, based on their units.\r\n     * Only converts, if both have units and the units are the same measure.\r\n     *\r\n     * @param {Object} assignedProperty assigned property of inputObject to a property of outputObject\r\n     * @param {Object} outputProperty the property of the outputObject that is matched with assignedProperty\r\n     * @returns {string|*} returns the converted value or empty String\r\n     */\r\n    convertValueWithUnit(assignedProperty, outputProperty){\r\n        let convert = require(\"convert-units\");\r\n        let assignedUnit = \"\", assignedUnitMeasure = \"\", outputUnit = \"\", outputUnitMeasure = \"\";\r\n\r\n        if(convert().lookup(assignedProperty.unit)){\r\n            let assignedUnitLookup = convert().lookup(assignedProperty.unit);\r\n            assignedUnit = assignedUnitLookup.abbr;\r\n            assignedUnitMeasure = assignedUnitLookup.measure;\r\n\r\n        }\r\n        if(convert().lookup(outputProperty.unit)){\r\n            let outputUnitLookUp = convert().lookup(assignedProperty.unit);\r\n            outputUnit = outputUnitLookUp.abbr;\r\n            outputUnitMeasure = outputUnitLookUp.measure;\r\n        }\r\n\r\n        if(assignedUnitMeasure !== \"\" && outputUnitMeasure !== \"\" && assignedUnitMeasure === outputUnitMeasure){\r\n            return convert(assignedProperty.value).from(assignedUnit).to(outputUnit);\r\n        }\r\n        else {\r\n            return \"\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Matches two assigned to each other properties of assignedGird and outputGrid.\r\n     * Converts property value of assignedGrid to the right format of the property in same row in outputGrid.\r\n     * Saves in matchedData name of outputProperties with the new value.\r\n     * Saves matched property names in matchedPairs.\r\n     *\r\n     * @param {Object[]} assignedGridData contains assigned properties of inputObject to properties of outputObject\r\n     * @param {Object[]} outputGridData contains the properties of the outputObject\r\n     * @returns {[][]} matchedData and matchedPairs\r\n     */\r\n    matchData(assignedGridData, outputGridData){\r\n        let matchedData = [], matchedPairs = [];\r\n\r\n        for (let i = 0; i < assignedGridData.length; i++) {\r\n            let assignedProperty = assignedGridData[i], outputProperty = outputGridData[i];\r\n\r\n            if(assignedProperty.name !== \"\"){\r\n                let convertedAssignedPropertyValue = this.convertValueWithUnit(assignedProperty, outputProperty);\r\n\r\n                if(convertedAssignedPropertyValue !== \"\") {\r\n                    matchedData.push({name: outputProperty.name, value: convertedAssignedPropertyValue});\r\n                    matchedPairs.push({outPropertyName: outputProperty.name, inPropertyName: assignedProperty.name})\r\n                }\r\n                else {\r\n                    matchedData.push({});\r\n                }\r\n            }\r\n            else {\r\n                matchedData.push({});\r\n            }\r\n        }\r\n        return [matchedData, matchedPairs];\r\n    }\r\n\r\n    /**\r\n     * Event handler.\r\n     * Calculates new values for outputProperties and the pairs that are matched with {@link matchData}.\r\n     * Does PUT request with matchedPairs to Matching API.\r\n     *\r\n     * @returns {Promise<void>}\r\n     */\r\n    async saveMatching(){\r\n        let assignedGridData = this.props.assignedGridData, outputGridData = this.props.outputGridData;\r\n\r\n        let [matchedData, matchedPairs] = this.matchData(assignedGridData, outputGridData);\r\n\r\n        let outputApiMatchedPairs = {virtualSatellite: matchedPairs};\r\n\r\n        await this.processOutputObjectProperties(matchedData);\r\n\r\n        const responseMatching = await fetch(\"http://localhost:8080/matchingWords\",{\r\n            method:\"PUT\",\r\n            headers:{\r\n                \"Accept\":\"application/json\",\r\n                \"Content-Type\":\"application/json\"\r\n            },\r\n            body:JSON.stringify(outputApiMatchedPairs)\r\n        });\r\n\r\n        this.setState({matchedData: matchedData});\r\n\r\n        this.setState({showNote: false});\r\n    }\r\n\r\n    /**\r\n     * Contains button component and PopUp (Modal).\r\n     * The button opens the PopUp and in the PopUp you can accept or decline a matching request.\r\n     *\r\n     * @returns {JSX.Element}\r\n     */\r\n    render() {\r\n        const screenWidth = window.innerWidth;\r\n        const screenHeight = window.innerHeight;\r\n\r\n        const buttonStyle={\r\n            marginTop: 10,\r\n            marginLeft: -55,\r\n            height: screenHeight*0.04,\r\n            width: screenWidth*0.08,\r\n            fontSize: 16,\r\n        }\r\n        const noteStyle = {\r\n            minHeight: screenHeight * 0.1,\r\n            maxHeight: screenHeight * 0.1,\r\n            minWidth: screenWidth * 0.15,\r\n            maxWidth: screenWidth * 0.15,\r\n        }\r\n        const noteText = {\r\n            height: screenHeight*0.05,\r\n            width: screenWidth*0.13,\r\n            border: \"none\",\r\n            textAlign: \"center\",\r\n        }\r\n\r\n        return(\r\n            <div>\r\n                <button style={buttonStyle} onClick={this.handleClick}>Save matching</button>\r\n                <Modal style={noteStyle} visible={this.state.showNote} maskClosable={true} closable={false} onCancel={this.closeNote}\r\n                       footer={[<button onClick={this.closeNote}>Cancel</button>, <button onClick={this.saveMatching}>Ok</button>]}>\r\n                    <input style={noteText} value={\"Do you really want to save this matching?\"} readOnly={true}/>\r\n                </Modal>\r\n            </div>\r\n        );\r\n    }\r\n}",{"ruleId":"79","replacedBy":"80"},{"ruleId":"81","replacedBy":"82"},{"ruleId":"79","replacedBy":"83"},{"ruleId":"81","replacedBy":"84"},{"ruleId":"85","severity":1,"message":"86","line":6,"column":9,"nodeType":"87","messageId":"88","endLine":6,"endColumn":20},{"ruleId":"85","severity":1,"message":"89","line":3,"column":17,"nodeType":"87","messageId":"88","endLine":3,"endColumn":22},{"ruleId":"90","severity":1,"message":"91","line":49,"column":40,"nodeType":"92","messageId":"93","endLine":49,"endColumn":42},{"ruleId":"90","severity":1,"message":"91","line":59,"column":40,"nodeType":"92","messageId":"93","endLine":59,"endColumn":42},{"ruleId":"90","severity":1,"message":"91","line":84,"column":33,"nodeType":"92","messageId":"93","endLine":84,"endColumn":35},{"ruleId":"90","severity":1,"message":"91","line":94,"column":40,"nodeType":"92","messageId":"93","endLine":94,"endColumn":42},{"ruleId":"85","severity":1,"message":"94","line":110,"column":15,"nodeType":"87","messageId":"88","endLine":110,"endColumn":25},{"ruleId":"90","severity":1,"message":"91","line":255,"column":41,"nodeType":"92","messageId":"93","endLine":255,"endColumn":43},{"ruleId":"90","severity":1,"message":"91","line":51,"column":69,"nodeType":"92","messageId":"93","endLine":51,"endColumn":71},{"ruleId":"90","severity":1,"message":"91","line":109,"column":55,"nodeType":"92","messageId":"93","endLine":109,"endColumn":57},{"ruleId":"85","severity":1,"message":"95","line":1,"column":16,"nodeType":"87","messageId":"88","endLine":1,"endColumn":25},{"ruleId":"85","severity":1,"message":"96","line":1,"column":27,"nodeType":"87","messageId":"88","endLine":1,"endColumn":38},{"ruleId":"90","severity":1,"message":"91","line":182,"column":50,"nodeType":"92","messageId":"93","endLine":182,"endColumn":52},{"ruleId":"90","severity":1,"message":"91","line":184,"column":58,"nodeType":"92","messageId":"93","endLine":184,"endColumn":60},{"ruleId":"90","severity":1,"message":"91","line":68,"column":58,"nodeType":"92","messageId":"93","endLine":68,"endColumn":60},{"ruleId":"90","severity":1,"message":"97","line":71,"column":46,"nodeType":"92","messageId":"93","endLine":71,"endColumn":48},{"ruleId":"85","severity":1,"message":"98","line":83,"column":19,"nodeType":"87","messageId":"88","endLine":83,"endColumn":35},{"ruleId":"85","severity":1,"message":"98","line":196,"column":15,"nodeType":"87","messageId":"88","endLine":196,"endColumn":31},"no-native-reassign",["99"],"no-negated-in-lhs",["100"],["99"],["100"],"no-unused-vars","'AgGridReact' is defined but never used.","Identifier","unusedVar","'Table' is defined but never used.","array-callback-return","Array.prototype.map() expects a return value from arrow function.","ArrowFunctionExpression","expectedInside","'CategoryId' is assigned a value but never used.","'createRef' is defined but never used.","'useCallback' is defined but never used.","Array.prototype.filter() expects a return value from arrow function.","'responseMatching' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]